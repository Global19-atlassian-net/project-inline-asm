- Feature Name: `asm`
- Start Date: (fill me in with today's date, YYYY-MM-DD)
- RFC PR: [rust-lang/rfcs#0000](https://github.com/rust-lang/rfcs/pull/0000)
- Rust Issue: [rust-lang/rust#0000](https://github.com/rust-lang/rust/issues/0000)

# Summary
[summary]: #summary

This RFC specifies a new syntax for inline assembly which is suitable for eventual stabilization.

The initial implementation of this feature will focus on the ARM, x86 and RISC-V architectures. Support for more architectures will be added based on user demand.

The existing `asm!` macro will be renamed to `llvm_asm!` to provide an easy way to maintain backwards-compatibility with existing code using inline asm. However `llvm_asm!` is not intended to ever be stabilized.

# Motivation
[motivation]: #motivation

In systems programming some tasks require dropping down to the assembly level. The primary reasons are for performance, precise timing, and low level hardware access. Using inline assembly for this is sometimes convenient, and sometimes necessary to avoid function call overhead.

The inline assembler syntax currently available in nightly Rust is very ad-hoc. It provides a thin wrapper over the inline assembly syntax available in LLVM IR. For stabilization a more user-friendly syntax that lends itself to implementation across various backends is preferable.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

Rust provides support for inline assembly via the `asm!` macro.
It can be used to embed handwritten assembly in the assembly output generated by the compiler.
Generally this should not be necessary, but might be where the required performance or timing
cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.

> Note: the examples here are given in x86/x86-64 assembly, but ARM, AArch64 and RISC-V are also supported.

## Basic usage

Let us start with the simplest possible example:

```rust
unsafe {
    asm!("nop");
}
```

This will insert a NOP (no operation) instruction into the assembly generated by the compiler.
Note that all `asm!` invocations have to be inside an `unsafe` block, as they could insert
arbitrary instructions and break various invariants. The instructions to be inserted are listed
in the first argument of the `asm!` macro as a string literal.

## Inputs and outputs

Now inserting an instruction that does nothing is rather boring. Let us do something that
actually acts on data:

```rust
let x: u32;
unsafe {
    asm!("mov {}, 5", out(reg) x);
}
assert_eq!(x, 5);
```

This will write the value `5` into the `u32` variable `x`.
You can see that the string literal we use to specify instructions is actually a template string.
It is governed by the same rules as Rust [format strings][format-syntax].
The arguments that are inserted into the template however look a bit different then you may
be familiar with. First we need to specify if the variable is an input or an output of the
inline assembly. In this case it is an output. We declared this by writing `out`.
We also need to specify in what kind of register the assembly expects the variable.
In this case we put it in an arbitrary general purpose register by specifying `reg`.
The compiler will choose an appropriate register to insert into
the template and will read the variable from there after the inline assembly finishes executing.

Let see another example that also uses an input:

```rust
let i: u32 = 3;
let o: u32;
unsafe {
    asm!("
        mov {0}, {1}
        add {0}, {number}
    ", out(reg) o, in(reg) i, number = imm 5);
}
assert_eq!(i, 8);
```

This will add `5` to the input in variable `i` and write the result to variable `o`.
The particular way this assembly does this is first copying the value from `i` to the output,
and then adding `5` to it.

The example shows a few things:

First we can see that inputs are declared by writing `in` instead of `out`.

Second one of our operands has a type we haven't seen yet, `imm`.
This tells the compiler to expand this argument to an immediate inside the assembly template.
This is only possible for constants and literals.

Third we can see that we can specify an argument number, or name as in any format string.
For inline assembly templates this is particularly useful as arguments are often used more than once.
For more complex inline assembly using this facility is generally recommended, as it improves
readability, and allows reordering instructions without changing the argument order.

We can further refine the above example to avoid the `mov` instruction:

```rust
let mut x: u32 = 3;
unsafe {
    asm!("add {0}, {number}", inout(reg) x, number = imm 5);
}
assert_eq!(x, 8);
```

We can see that `inout` is used to specify an argument that is both input and output.
This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.

It is also possible to specify different variables for the input and output parts of an `inout` operand:

```rust
let x: u32 = 3;
let y: u32;
unsafe {
    asm!("add {0}, {number}", inout(reg) x => y, number = imm 5);
}
assert_eq!(y, 8);
```

## Late output operands

The Rust compiler is conservative with its allocation of operands. It is assumed that an `out`
can be written at any time, and can therefore not share its location with any other argument.
However, to guarantee optimal performance it is important to use as few registers as possible,
so they won't have to be saved and reloaded around the inline assembly block.
To achieve this Rust provides a `lateout` specifier. This can be used on any output that is
guaranteed to be written only after all inputs have been consumed.
There is also a `inlateout` variant of this specifier.

Here is an example where `inlateout` *cannot* be used:

```rust
let mut a = 4;
let b = 4;
let c = 4;
unsafe {
    asm!("
        add {0}, {1}
        add {0}, {2}
    ", inout(reg) a, in(reg) b, in(reg) c);
}
assert_eq!(a, 12);
```

Here the compiler is free to allocate the same register for inputs `b` and `c` since it knows they have the same value. However it must allocate a separate register for `a` since it uses `inout` and not `inlateout`.

However the following example can use `inlateout` since the output is only modified after all input registers have been read:

```rust
let mut a = 4;
let b = 4;
unsafe {
    asm!("add {0}, {1}", inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
```

As you can see, this assembly fragment will still work correctly if `a` and `b` are assigned to the same register.

## Explicit register operands

Some instructions require that the operands be in a specific register.
Therefore, Rust inline assembly provides some more specific constraint specifiers.
While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`
among others can be addressed by their name.

```rust
unsafe {
    asm!("out 0x64, {}", in("eax") cmd);
}
```

In this example we call the `out` instruction to output the content of the `cmd` variable
to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand
we had to use the `eax` constraint specifier.

It is somewhat common that instructions have operands that are not explicitly listed in the
assembly (template). Hence, unlike in regular formatting macros, we support excess arguments:

```rust
fn mul(a: u32, b: u32) -> u64 {
    let lo: u32;
    let hi: u32;

    unsafe {
        asm!(
            // The x86 mul instruction takes eax as an implicit input and writes
            // the 64-bit result of the multiplication to eax:edx.
            "mul {}",
            in(reg) a, in("eax") b,
            lateout("eax") lo, lateout("edx") hi
        );
    }

    hi as u64 << 32 + lo as u64
}
```

This uses the `mul` instruction to multiply two 32-bit inputs with a 64-bit result.
The only explicit operand is a register, that we fill from the variable `a`.
The second implicit operand is the `eax` register which we fill from the variable `b`.
The lower 32 bits of the result are stored in `eax` from which we fill the variable `lo`.
The higher 32 bits are stored in `edx` from which we fill the variable `hi`.

Note that `lateout` must be used for `eax` here since we are specifying the same register as both an input and an output.

## Clobbered registers

In many cases inline assembly will modify state that is not needed as an output.
Usually this is either because we have to use a scratch register in the assembly,
or instructions modify state that we don't need to further examine.
This state is generally referred to as being "clobbered".
We need to tell the compiler about this since it may need to save and restore this state
around the inline assembly block.

```rust
let ebx: u32;
let ecx: u32;

unsafe {
    asm!(
        "cpuid",
        in("eax") 4, in("ecx") 0,
        lateout("ebx") ebx, lateout("ecx") ecx,
        lateout("eax") _, lateout("edx") _
    );
}

println!(
    "L1 Cache: {}",
    ((ebx >> 22) + 1) * (((ebx >> 12) & 0x3ff) + 1) * ((ebx & 0xfff) + 1) * (ecx + 1)
);
```

In the example above we use the `cpuid` instruction to get the L1 cache size.
This instruction writes to `eax`, `ebx`, `ecx`, and `edx`, but for the cache size we only care about the contents of `ebx` and `ecx`.

However we still need to tell the compiler that `eax` and `edx` have been modified so that it can save any values that were in these registers before the asm. This is done by declaring these as outputs but with `_` instead of a variable name, which indicates that the output value is to be discarded.

This can also be used with a general register class (e.g. `reg`) to obtain a scratch register for use inside the asm code.

## Register template modifiers

In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a "view" over a subset of the register (e.g. the low 32 bits of a 64-bit register).

```rust
let mut x: u16 = 0xab;

unsafe {
    asm!("mov {0:h} {0:b}", inout(reg_abcd) x);
}

assert_eq!(x, 0xabab);
```

In this example, we use the `reg_abcd` register class to restrict the register allocator to the 4 legacy x86 register (`ax`, `bx`, `cx`, `dx`) of which the first two bytes can be addressed independently.

Let us assume that the register allocator has chosen to allocate `x` in the `ax` register.
The `h` modifier will emit the register name for the high byte of that register and the `b` modifier will emit the register name for the low byte. The asm code will therefore be expanded as `mov ah, al` which copies the low byte of the value into the high byte.

## Flags

By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.

Let's take our previous example of an `add` instruction:

```rust
let mut a = 4;
let b = 4;
unsafe {
    asm!(
        "add {0}, {1}",
        inlateout(reg) a, in(reg) b,
        flags(pure, nomem, nostack)
    );
}
assert_eq!(a, 8);
```

Flags can be provided as an optional final argument to the `asm!` macro. We specified three flags here:
- `pure` means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.
- `nomem` means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).
- `nostack` means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86_64 to avoid stack pointer adjustments.

These allow the compiler to better optimize code using `asm!`, for example by eliminating pure `asm!` blocks whose outputs are not needed.

See the reference for the full list of available flags and their effects.

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

Inline assembler is implemented as an unsafe macro `asm!()`.
The first argument to this macro is a template string literal used to build the final assembly.
The following arguments specify input and output operands.
When required, flags are specified as the final argument.

The following ABNF specifies the general syntax:

```
dir_spec := "in" / "out" / "lateout" / "inout" / "inlateout"
reg_spec := <arch specific register class> / "<arch specific register name>"
operand_expr := expr / "_" / expr "=>" expr / expr "=>" "_"
reg_operand := dir_spec "(" reg_spec ")" operand_expr
operand := reg_operand / "imm" const_expr / "sym" path
flag := "pure" / "nomem" / "readonly" / "preserves_flags" / "noreturn"
flags := "flags(" flag *["," flag] ")"
asm := "asm!(" format_string *("," [ident "="] operand) ["," flags] ")"
```

[format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax

## Template string

The assembler template uses the same syntax as [format strings][format-syntax] (i.e. placeholders are specified by curly braces). The corresponding arguments are accessed in order, by index, or by name. However, implicit named arguments (introduced by [RFC #2795][rfc-2795]) are not supported.

The assembly code syntax used is that of the GNU assembler (GAS). The only exception is on x86 where the Intel syntax is used instead of GCC's AT&T syntax.

This RFC only specifies how operands are substituted into the template string. Actual interpretation of the final asm string is left to the assembler.

However there is one restriction on the asm string: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string.

The compiler will lint against any operands that are not used in the template string, except for operands that specify an explicit register.

[rfc-2795]: https://github.com/rust-lang/rfcs/pull/2795

## Operand type

Several types of operands are supported:

* `in(<reg>) <expr>`
  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.
  - The allocated register will contain the value of `<expr>` at the start of the asm code.
  - The allocated register must contain the same value at the end of the asm code (except if a `lateout` is allocated to the same register).
* `out(<reg>) <expr>`
  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.
  - The allocated register will contain an unknown value at the start of the asm code.
  - `<expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.
  - An underscore (`_`) may be specified instead of an expression, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).
* `lateout(<reg>) <expr>`
  - Identical to `out` except that the register allocator can reuse a register allocated to an `in`.
  - You should only write to the register after all inputs are read, otherwise you may clobber an input.
  - `lateout` must be used instead of `out` if you are specifying the same explicit register as an `in`.
* `inout(<reg>) <expr>`
  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.
  - The allocated register will contain the value of `<expr>` at the start of the asm code.
  - `<expr>` must be an initialized place expression, to which the contents of the allocated register is written to at the end of the asm code.
* `inout(<reg>) <in expr> => <out expr>`
  - Same as `inout` except that the initial value of the register is taken from the value of `<in expr>`.
  - `<out expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.
  - An underscore (`_`) may be specified instead of an expression for `<out expr>`, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).
  - `<in expr>` and `<out expr>` may have different types.
* `inlateout(<reg>) <expr>` / `inlateout(<reg>) <in expr> => <out expr>`
  - Identical to `inout` except that the register allocator can reuse a register allocated to an `in` (this can happen if the compiler knows the `in` has the same initial value as the `inlateout`).
  - You should only write to the register after all inputs are read, otherwise you may clobber an input.
* `imm <expr>`
  - `<expr>` must be an integer or floating-point constant expression.
  - The value of the expression is formatted as a string and substituted directly into the asm template string.
* `sym <path>`
  - `<path>` must refer to a `fn` or `static` defined in the current crate.
  - A mangled symbol name referring to the item is substituted into the asm template string.
  - The substituted string does not include any modifiers (e.g. GOT, PLT, relocations, etc).

## Register operands

Input and output operands can be specified either as an explicit register or as a register class from which the register allocator can select a register. Explicit registers are specified as string literals (e.g. `"eax"`) while register classes are specified as raw identifiers (e.g. `reg`).

Note that explicit registers treat register aliases (e.g. `r14` vs `lr` on ARM) and smaller views of a register (e.g. `eax` vs `rax`) as equivalent to the base register. It is a compile-time error to use the same explicit register two input operand or two output operands. Additionally on ARM, it is a compile-time error to use overlapping VFP registers in input operands or in output operands.

Different registers classes have different constraints on which Rust types they allow. For example, `reg` generally only allows integers and pointers, but not floats or SIMD vectors.

If a value is of a smaller size than the register it is allocated in then the upper bits of that register will have an undefined value for inputs and will be ignored for outputs. It is a compile-time error for a value to be of a larger size than the register it is allocated in.

Here is the list of currently supported register classes:

| Architecture | Register class | Registers | LLVM constraint code | Allowed types |
| ------------ | -------------- | --------- | ----- | ------------- |
| x86 | `reg` | `ax`, `bx`, `cx`, `dx`, `si`, `di`, `r[8-15]` (x86-64 only) | `r` | `i8`, `i16`, `i32`, `i64` (x86-64 only) |
| x86 | `reg_abcd` | `ax`, `bx`, `cx`, `dx` | `Q` | `i8`, `i16`, `i32`, `i64` (x86-64 only) |
| x86 | `vreg` | `xmm[0-7]` (x86) `xmm[0-15]` (x86-64) | `x` | `i32`, `i64`, `f32`, `f64`, `v128`, `v256`, `v512` |
| x86 | `vreg_evex` | `xmm[0-31]` (AVX-512, otherwise same as `vreg`) | `v` | `i32`, `i64`, `f32`, `f64`, `v128`, `v256`, `v512` |
| x86 (AVX-512) | `kreg` | `k[1-7]` | `Yk` | `i16`, `i32`, `i64` |
| AArch64 | `reg` | `x[0-28]`, `x30` | `r` | `i8`, `i16`, `i32`, `i64` |
| AArch64 | `vreg` | `v[0-31]` | `w` | `i8`, `i16`, `i32`, `i64`, `f32`, `f64`, `v64`, `v128` |
| AArch64 | `vreg_low` | `v[0-15]` | `x` | `i8`, `i16`, `i32`, `i64`, `f32`, `f64`, `v64`, `v128` |
| AArch64 | `vreg_low8` | `v[0-7]` | `y` | `i8`, `i16`, `i32`, `i64`, `f32`, `f64`, `v64`, `v128` |
| ARM | `reg` | `r[0-r10]`, `r12`, `r14` | `r` | `i8`, `i16`, `i32` |
| ARM | `vreg` | `s[0-31]`, `d[0-31]`, `q[0-15]` | `w` | `f32`, `f64`, `v64`, `v128` |
| ARM | `vreg_low` | `s[0-31]`, `d[0-15]`, `q[0-7]` | `t` | `f32`, `f64`, `v64`, `v128` |
| ARM | `vreg_low8` | `s[0-15]`, `d[0-d]`, `q[0-3]` | `x` | `f32`, `f64`, `v64`, `v128` |
| RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-31]` | `r` | `i8`, `i16`, `i32`, `i64` (RV64 only) |
| RISC-V | `vreg` | `f[0-31]` | `f` | `f32`, `f64` |

> Notes on allowed types:
> - Pointers and references are allowed where the equivalent integer type is allowed.
> - `iLEN` refers to both sized and unsized integer types. It also implicitly includes `isize` and `usize` where the length matches.
> - Fat pointers are not allowed.
> - `vLEN` refers to a SIMD vector that is `LEN` bits wide.

Additional constraint specifications may be added in the future based on demand for additional register classes (e.g. MMX, x87, etc).

Some registers have multiple names. These are all treated by the compiler as identical to the base register name. Here is the list of all supported register aliases:

| Architecture | Base register | Aliases |
| ------------ | ------------- | ------- |
| x86 | `ax` | `al`, `eax`, `rax` |
| x86 | `bx` | `bl`, `ebx`, `rbx` |
| x86 | `cx` | `cl`, `ecx`, `rcx` |
| x86 | `dx` | `dl`, `edx`, `rdx` |
| x86 | `si` | `sil`, `esi`, `rsi` |
| x86 | `di` | `dil`, `edi`, `rdi` |
| x86 | `bp` | `bpl`, `ebp`, `rbp` |
| x86 | `sp` | `spl`, `esp`, `rsp` |
| x86 | `ip` | `eip`, `rip` |
| x86 | `r[8-15]` | `r[8-15]b`, `r[8-15]w`, `r[8-15]d` |
| x86 | `xmm[0-31]` | `ymm[0-31]`, `zmm[0-31]` |
| AArch64 | `x[0-30]` | `w[0-30]` |
| AArch64 | `x29` | `fp` |
| AArch64 | `x30` | `lr` |
| AArch64 | `sp` | `wsp` |
| AArch64 | `xzr` | `wzr` |
| AArch64 | `v[0-31]` | `b[0-31]`, `h[0-31]`, `s[0-31]`, `d[0-31]`, `q[0-31]` |
| ARM | `r[0-3]` | `a[1-4]` |
| ARM | `r[4-9]` | `v[1-6]` |
| ARM | `r9` | `rfp` |
| ARM | `r10` | `sl` |
| ARM | `r11` | `fp` |
| ARM | `r12` | `ip` |
| ARM | `r13` | `sp` |
| ARM | `r14` | `lr` |
| ARM | `r15` | `pc` |
| RISC-V | `x0` | `zero` |
| RISC-V | `x1` | `ra` |
| RISC-V | `x2` | `sp` |
| RISC-V | `x3` | `gp` |
| RISC-V | `x4` | `tp` |
| RISC-V | `x[5-7]` | `t[0-2]` |
| RISC-V | `x8` | `fp`, `s0` |
| RISC-V | `x9` | `s1` |
| RISC-V | `x[10-17]` | `a[0-7]` |
| RISC-V | `x[18-27]` | `s[2-11]` |
| RISC-V | `x[28-31]` | `t[3-6]` |
| RISC-V | `f[0-7]` | `ft[0-7]` |
| RISC-V | `f[8-9]` | `fs[0-1]` |
| RISC-V | `f[10-17]` | `fa[0-7]` |
| RISC-V | `f[18-27]` | `fs[2-11]` |
| RISC-V | `f[28-31]` | `ft[8-11]` |

Some registers cannot be used for input or output operands:

| Architecture | Unsupported register | Reason |
| ------------ | -------------------- | ------ |
| All | `sp` | The stack pointer must be restored to its original value at the end of an asm code block. |
| All | `bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V) | The frame pointer cannot be used as an input or output. |
| x86 | `ah`, `bh`, `ch`, `dh` | These are poorly supported by compiler backends. Use 16-bit register views (e.g. `ax`) instead. |
| x86 | `k0` | This is a constant zero register which can't be modified. |
| x86 | `ip` | This is the program counter, not a real register. |
| AArch64 | `xzr` | This is a constant zero register which can't be modified. |
| ARM | `pc` | This is the program counter, not a real register. |
| RISC-V | `x0` | This is a constant zero register which can't be modified. |
| RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |

## Template modifiers

The placeholders can be augmented by modifiers which are specified after the `:` in the curly braces. These modifiers do not affect register allocation, but change the way operands are formatted when inserted into the template string. Only one modifier is allowed per template placeholder.

The supported modifiers are a subset of LLVM's (and GCC's) [asm template argument modifiers][llvm-argmod].

| Architecture | Register class | Modifier | Input type | Example output |
| ------------ | -------------- | -------- | ---------- | -------------- |
| x86 | `reg` | None | `i8` | `al` |
| x86 | `reg` | None | `i16` | `ax` |
| x86 | `reg` | None | `i32` | `eax` |
| x86 | `reg` | None | `i64` | `rax` |
| x86-32 | `reg_abcd` | `b` | Any | `al` |
| x86-64 | `reg` | `b` | Any | `al` |
| x86 | `reg_abcd` | `h` | Any | `ah` |
| x86 | `reg` | `w` | Any | `ax` |
| x86 | `reg` | `k` | Any | `eax` |
| x86-64 | `reg` | `q` | Any | `rax` |
| x86 | `vreg` | None | `i32`, `i64`, `f32`, `f64`, `v128` | `xmm0` |
| x86 (AVX) | `vreg` | None | `v256` | `ymm0` |
| x86 (AVX-512) | `vreg` | None | `v512` | `zmm0` |
| x86 (AVX-512) | `kreg` | None | Any | `k1` |
| AArch64 | `reg` | None | Any | `x0` |
| AArch64 | `reg` | `w` | Any | `w0` |
| AArch64 | `reg` | `x` | Any | `x0` |
| AArch64 | `vreg` | None | Any | `v0` |
| AArch64 | `vreg` | `b` | Any | `b0` |
| AArch64 | `vreg` | `h` | Any | `h0` |
| AArch64 | `vreg` | `s` | Any | `s0` |
| AArch64 | `vreg` | `d` | Any | `d0` |
| AArch64 | `vreg` | `q` | Any | `q0` |
| ARM | `reg` | None | Any | `r0` |
| ARM | `vreg` | None | `f32` | `s0` |
| ARM | `vreg` | None | `f64`, `v64` | `d0` |
| ARM | `vreg` | None | `v128` | `q0` |
| ARM | `vreg` | `e` / `f` | `v128` | `d0` / `d1` |
| RISC-V | `reg` | None | Any | `x1` |
| RISC-V | `vreg` | None | Any | `f0` |

> Notes:
> - on ARM `e` / `f`: this prints the low or high doubleword register name of a NEON quad (128-bit) register.
> - on AArch64 `reg`: a warning is emitted if the input type is smaller than 64 bits, suggesting to use the `w` modifier. The warning can be suppressed by explicitly using the `x` modifier.

[llvm-argmod]: http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers

## Flags

Flags are used to further influence the behavior of the inline assembly block.
Currently the following flags are defined:
- `pure`: The `asm` block has no side effects, and its outputs depend only on its direct inputs (i.e. the values themselves, not what they point to). This allows the compiler to execute the `asm` block fewer times than specified in the program (e.g. by hoisting it out of a loop) or even eliminate it entirely if the outputs are not used. A warning is emitted if this flag is used on an `asm` with no outputs.
- `nomem`: The `asm` blocks does not read or write to any memory. This allows the compiler to cache the values of modified global variables in registers across the `asm` block since it knows that they are not read or written to by the `asm`.
- `readonly`: The `asm` block does not write to any memory. This allows the compiler to cache the values of unmodified global variables in registers across the `asm` block since it knows that they are not written to by the `asm`.
- `preserves_flags`: The `asm` block does not modify the flags register (defined below). This allows the compiler to avoid recomputing the condition flags after the `asm` block.
- `noreturn`: The `asm` block never returns, and its return type is defined as `!` (never). Behavior is undefined if execution falls through past the end of the asm code.
- `nostack`: The `asm` block does not push data to the stack, or write to the stack red-zone (if supported by the target). If this flag is *not* used then the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.

The `nomem` and `readonly` flags are mutually exclusive: it is an error to specify both. Specifying `pure` on an asm block with no outputs is linted against since such a block will be optimized away to nothing.

These flag registers which must be preserved if `preserves_flags` is set:
- x86
  - Status flags in `EFLAGS` (CF, PF, AF, ZF, SF, OF).
  - Direction flag in `EFLAGS` (DF).
  - Floating-point status word (all).
  - Floating-point exception flags in `MXCSR` (PE, UE, OE, ZE, DE, IE).
- ARM
  - Condition flags in `CPSR` (N, Z, C, V)
  - Saturation flag in `CPSR` (Q)
  - Greater than or equal flags in `CPSR` (GE).
  - Condition flags in `FPSCR` (N, Z, C, V)
  - Saturation flag in `FPSCR` (QC)
  - Floating-point exception flags in `FPSCR` (IDC, IXC, UFC, OFC, DZC, IOC).
- AArch64
  - Condition flags (`NZCV` register).
  - Floating-point status (`FPSR` register).
- RISC-V
  - Floating-point exception flags in `fcsr` (`fflags`).

> Note: As a general rule, these are the flags which are *not* preserved when performing a function call.

## Mapping to LLVM IR

The direction specification maps to a LLVM constraint specification as follows (using a `reg` operand as an example):

* `in(reg)` => `r`
* `out(reg)` => `=&r` (Rust's outputs are early-clobber outputs in LLVM/GCC terminology)
* `inout(reg)` => `=&r,0` (an early-clobber output with an input tied to it, `0` here is a placeholder for the position of the output)
* `lateout(reg)` => `=r` (Rust's late outputs are regular outputs in LLVM/GCC terminology)
* `inlateout(reg)` => `=r, 0` (cf. `inout` and `lateout`)

If an `inout` is used where the output type is smaller than the input type then some special handling is needed to avoid LLVM issues. See [this bug][issue-65452].

As written this RFC requires architectures to map from Rust constraint specifications to LLVM constraint codes. This is in part for better readability on Rust's side and in part for independence of the backend:

* Register classes are mapped to the appropriate constraint code as per the table above.
* `imm` operands are formatted and injected directly into the asm string.
* `sym` is mapped to `s` for statics and `X` for functions.
* a register name `r1` is mapped to `{r1}`
* additionally mappings for register classes are added as appropriate (cf. [llvm-constraint])
* `lateout` operands with an `_` expression that are specified as an explicit register are converted to LLVM clobber constraints. For example, `lateout("r1") _` is mapped to `~{r1}` (cf. [llvm-clobber]).
* If the `nomem` flag is not set then `~{memory}` is added to the clobber list. (Although this is currently ignored by LLVM)
* If the `preserves_flags` flag is not set then the following are added to the clobber list:
  - (x86) `~{dirflag}~{flags}~{fpsr}`
  - (ARM/AArch64) `~{cc}`

For some operand types, we will automatically insert some modifiers into the template string.
* For `sym` and `imm` operands, we automatically insert the `c` modifier which removes target-specific modifiers from the value (e.g. `#` on ARM).
* On AArch64, we will warn if a value smaller than 64 bits is used without a modifier since this is likely a bug (it will produce `x*` instead of `w*`). Clang has this same warning.
* On ARM, we will automatically add the `P` or `q` LLVM modifier for `f64`, `v64` and `v128` passed into a `vreg`. This will cause those registers to be formatted as `d*` and `q*` respectively.

Additionally, the following attributes are added to the LLVM `asm` statement:

* The `nounwind` attribute is always added: unwinding from an inline asm block is not allowed (and not supported by LLVM anyways).
* If the `nomem` flag is set then the `readnone` attribute is added to the LLVM `asm` statement.
* If the `readonly` flag is set then the `readonly` attribute is added to the LLVM `asm` statement.
* If the `pure` flag is not set then the `sideffect` flag is added the LLVM `asm` statement.
* If the `nostack` flag is not set then the `alignstack` flag is added the LLVM `asm` statement.
* On x86 the `inteldialect` flag is added the LLVM `asm` statement so that the Intel syntax is used instead of the AT&T syntax.

If the `noreturn` flag is set then an `unreachable` LLVM instruction is inserted after the asm invocation.

> Note that `alignstack` is not currently supported by GCC, so we will need to implement support in GCC if Rust ever gets a GCC back-end.

[llvm-constraint]: http://llvm.org/docs/LangRef.html#supported-constraint-code-list
[llvm-clobber]: http://llvm.org/docs/LangRef.html#clobber-constraints
[issue-65452]: https://github.com/rust-lang/rust/issues/65452

# Drawbacks
[drawbacks]: #drawbacks

## Unfamiliarity

This RFC proposes a completely new inline assembly format.
It is not possible to just copy examples of GCC-style inline assembly and re-use them.
There is however a fairly trivial mapping between the GCC-style and this format that could be documented to alleviate this.

Additionally, this RFC proposes using the Intel asm syntax on x86 instead of the AT&T syntax. We believe this syntax will be more familiar to most users, but may be surprising for users used to GCC-style asm.

The `cpuid` example above would look like this in GCC-sytle inline assembly:

```C
// GCC doesn't allow directly clobbering an input, we need
// to use a dummy output instead.
int ebx, ecx, discard;
asm (
    "cpuid"
    : "=a"(discard), "=b"(ebx), "=c"(ecx) // outputs
    : "a"(4), "c"(0) // inputs
    : "edx" // clobbers
);
printf("L1 Cache: %i\n", ((ebx >> 22) + 1)
    * (((ebx >> 12) & 0x3ff) + 1)
    * ((ebx & 0xfff) + 1)
    * (ecx + 1));
```

## Limited set of operand types

The proposed set of operand types is much smaller than that which is available through GCC-style inline assembly. In particular, the proposed syntax does not include any form of memory operands and is missing many register classes.

We chose to keep operand constraints as simple as possible, and in particular memory operands introduce a lot of complexity since different instruction support different addressing modes. At the same time, the exact rules for memory operands are not very well known (you are only allowed to access the data directly pointed to by the constraint) and are often gotten wrong.

If we discover that there is a demand for a new register class or special operand type, we can always add it later.

## Difficulty of support

Inline assembly is a difficult feature to implement in a compiler backend. While LLVM does support it, this may not be the case for alternative backends such as [Cranelift][cranelift] (see [this issue][cranelift-asm]).

However it is possible to implement support for inline assembly without support from the compiler backend by using an external assembler instead. Take the following (AArch64) asm block as an example:

```rust
unsafe fn foo(mut a: i32, b: i32) -> (i32, i32)
{
    let c;
    asm!("<some asm code>", inout(reg) a, in("x0") b, out("x20") c);
    (a, c)
}
```

This could be expanded to an external asm file with the following contents:

```
# Function prefix directives
.section ".text.foo_inline_asm"
.globl foo_inline_asm
.p2align 2
.type foo_inline_asm, @function
foo_inline_asm:

// If necessary, save callee-saved registers to the stack here.
str x20, [sp, #-16]!

// Move the pointer to the argument out of the way since x0 is used.
mov x1, x0

// Load inputs values
ldr w2, [x1, #0]
ldr w0, [x1, #4]

<some asm code>

// Store output values
str w2, [x1, #0]
str w20, [x1, #8]

// If necessary, restore callee-saved registers here.
ldr x20, [sp], #16

ret

# Function suffix directives
.size foo_inline_asm, . - foo_inline_asm
```

And the following Rust code:

```rust
unsafe fn foo(mut a: i32, b: i32) -> (i32, i32)
{
    let c;
    {
        #[repr(C)]
        struct foo_inline_asm_args {
            a: i32,
            b: i32,
            c: i32,
        }
        extern "C" {
            fn foo_inline_asm(args: *mut foo_inline_asm_args);
        }
        let mut args = foo_inline_asm_args {
            a: a,
            b: b,
            c: mem::uninitialized(),
        };
        foo_inline_asm(&mut args);
        a = args.a;
        c = args.c;
    }
    (a, c)
}
```

[cranelift]: https://cranelift.readthedocs.io/
[cranelift-asm]: https://github.com/bytecodealliance/cranelift/issues/444

## Use of double braces in the template string

Because `{}` are used to denote operand placeholders in the template string, actual uses of braces in the assembly code need to be escaped with `{{` and `}}`. This is needed for AVX-512 mask registers and ARM register lists.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

## Implement an embedded DSL
[dsl]: #dsl

Both MSVC and D provide what is best described as an embedded DSL for inline assembly.
It is generally close to the system assembler's syntax, but augmented with the ability to directly access variables that are in scope.

```D
// This is D code
int ebx, ecx;
asm {
    mov EAX, 4;
    xor ECX, ECX;
    cpuid;
    mov ebx, EBX;
    mov ecx, ECX;
}
writefln("L1 Cache: %s",
    ((ebx >> 22) + 1) * (((ebx >> 12) & 0x3ff) + 1)
    * ((ebx & 0xfff) + 1) * (ecx + 1));
```

```C++
// This is MSVC C++
int ebx_v, ecx_v;
__asm {
    mov eax, 4
    xor ecx, ecx
    cpuid
    mov ebx_v, ebx
    mov ecx_v, ecx
}
std::cout << "L1 Cache: "
    << ((ebx_v >> 22) + 1) * (((ebx_v >> 12) & 0x3ff) + 1)
        * ((ebx_v & 0xfff) + 1) * (ecx_v + 1))
    << '\n';
```

While this is very convenient on the user side in that it requires no specification of inputs,
outputs, or clobbers, it puts a major burden on the implementation.
The DSL needs to be implemented for each supported architecture, and full knowledge of the
side-effect of every instruction is required.

This huge implementation overhead is likely one of the reasons MSVC only
provides this capability for x86, while D at least provides it for x86 and x86-64.
It should also be noted that the D reference implementation falls slightly short of supporting
arbitrary assembly. E.g. the lack of access to the `RIP` register makes certain techniques for
writing position independent code impossible.

As a stop-gap the LDC implementation of D provides a `llvmasm` feature that binds it closely
to LLVM IR's inline assembly.

We believe it would be unfortunate to put Rust into a similar situation, making certain
architectures a second-class citizen with respect to inline assembly.

## Provide intrinsics for each instruction

In discussions it is often postulated that providing intrinsics is a better solution to the
problems at hand.
However, particularly where precise timing, and full control over the number of generated
instructions is required intrinsics fall short.

Intrinsics are of course still useful and have their place for inserting specific instructions.
E.g. making sure a loop uses vector instructions, rather than relying on auto-vectorization.

However, inline assembly is specifically designed for cases where more control is required.
Also providing an intrinsic for every (potentially obscure) instruction that is needed
e.g. during early system boot in kernel code is unlikely to scale.

## Make the `asm!` macro return outputs

It has been suggested that the `asm!` macro could return its outputs like the LLVM statement does.
The benefit is that it is clearer to see that variables are being modified.
Particular in the case of initialization it becomes more obvious what is happening.
On the other hand by necessity this splits the direction and constraint specification from
the variable name, which makes this syntax overall harder to read.

```rust
fn mul(a: u32, b: u32) -> u64 {
    let (lo, hi) = unsafe {
        asm!("mul {}", in(reg) a, in("eax") b, lateout("eax"), lateout("edx"))
    };

    hi as u64 << 32 + lo as u64
}
```

# Prior art
[prior-art]: #prior-art

## GCC inline assembly

The proposed syntax is very similar to GCC's inline assembly in that it is based on string substitution while leaving actual interpretation of the final string to the assembler. However GCC uses poorly documented single-letter constraint codes and template modifiers. Clang tries to emulate GCC's behavior, but there are still several cases where its behavior differs from GCC's.

The main reason why this is so complicated is that GCC's inline assembly basically exports the raw internals of GCC's register allocator. This has resulted in many internal constraint codes and modifiers being widely used, despite them being completely undocumented.

## D & MSVC inline assembly

See the section [above][dsl].

# Unresolved questions
[unresolved-questions]: #unresolved-questions

None

# Future possibilities
[future-possibilities]: #future-possibilities

## Flag outputs

GCC supports a special type of output which allows an asm block to return a `bool` encoded in the condition flags register. This allows the compiler to branch directly on the condition flag instead of materializing the condition as a `bool`.

We can support this in the future with a special output operand type.

## `asm goto`

GCC supports passing C labels (the ones used with `goto`) to an inline asm block, with an indication that the asm code may jump directly to one of these labels instead of leaving the asm block normally.

This could be supported by allowing code blocks to be specified as operand types. The following code will print `a` if the input value is `42`, or print `b` otherwise.

```rust
asm!("cmp {}, 42; jeq {}",
    in(reg) val,
    label { println!("a"); },
    fallthrough { println!("b"); }
);
```

## Unique ID per `asm`

GCC supports `%=` which generates a unique identifier per instance of an asm block. This is guaranteed to be unique even if the asm block is duplicated (e.g. because of inlining).

We can support this in the future with a special operand type.

## `imm` and `sym` for `global_asm!`

The `global_asm!` macro could be extended to support `imm` and `sym` operands since those can be resolved by simple string substitution. Symbols used in `global_asm!` will be marked as `#[used]` to ensure that they are not optimized away by the compiler.

## Memory operands

We could support `mem` as an alternative to specifying a register class which would leave the operand in memory and instead produce a memory address when inserted into the asm string. This would allow generating more efficient code by taking advantage of addressing modes instead of using an intermediate register to hold the computed address.

## Shorthand notation for operand names

We should support some sort of shorthand notation for operand names to avoid needing to write `blah = out(reg) blah`? For example, if the expression is just a single identifier, we could implicitly allow that operand to be referred to using that identifier.

## Clobbers for function calls

Sometimes it can be difficult to specify the necessary clobbers for an asm block which performs a function call. In particular, it is difficult for such code to be forward-compatible if the architecture adds new registers in a future revision, which the compiler may use but will be missing from the `asm!` clobber list.

One possible solution to this would be to add a `clobber(<abi>)` operand where `<abi>` is a calling convention such as `"C"` or `"stdcall"`. The compiler would then automatically insert the necessary clobbers for a function call to that ABI. Also `clobber(all)`, could be used to indicate all registers are clobbered by the `asm!`.
